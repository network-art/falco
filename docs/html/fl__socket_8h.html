<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>falco: include/falco/fl_socket.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">falco
   </div>
   <div id="projectbrief">C library for developing embedded and network applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_46622faca203c2925f5897ab99c3fb08.html">falco</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">fl_socket.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sockets and communications.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Sockets and communications. </p>
<p>At the heart of the falco socket module is the notion or concept of a "Falco
Socket" (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8" title="Falco Socket. ">fl_socket_t</a>). The falco socket is a structure that contains the socket file descriptor (sockfd). It also contains many other properties/attributes that help applications (and the falco library itself) perform various operations on the sockfd. The commentary on the source code often refer to this concept of falco socket. This is not to be confused with the socket file descriptor (sockfd) containined within the falco socket.</p>
<p>Throughout the code, falco sockets are represented by <em><b>flsk</b></em>. Throughout the code and commentary, the socket file descriptor (contained within a falco socket) is represented by <em><b>sockfd</b></em>. Functions, structure definitions, and enumerations are prefixed with <em>fl_socket_</em>.</p>
<p>This module provides APIs for the following functionalities.</p><ul>
<li>Create, close/delete sockets.</li>
<li>Accept connections (server) and connect method (client).</li>
<li>Send and Receive data (TCP, UDP, and RAW IP). Blocking and Non-Blocking operations are supported.</li>
</ul>
<p>The following socket domains (address families) are supported.</p><ul>
<li>AF_INET (IPv4 Internet Protocols)</li>
<li>AF_INET6 (IPv6 Internet Protocols)</li>
<li>AF_UNIX (Local Communication)</li>
</ul>
<p>The following socket types, which spcecify the communication semantics, are supported.</p><ul>
<li>SOCK_DGRAM</li>
<li>SOCK_RAW</li>
<li>SOCK_STREAM</li>
</ul>
<p>All APIs that accept parameter of type sockaddr or sockaddr_storage check the above socket domains (or address families) and socket types.</p>
<p><em><b>sockaddr_storage</b></em> is used instead of <code>sockaddr</code> in APIs such <a class="el" href="fl__socket_8h.html#a9ec528fb8fbfd7e88412425267ff95c8" title="Bind a name to a falco socket. ">fl_socket_bind()</a>. This is so that applications can allocate for the maximum size of a socket address instead of running into size/cast issues. </p>
</div><div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;sys/un.h&gt;</code><br />
<code>#include &lt;sys/queue.h&gt;</code><br />
<code>#include &lt;netinet/in.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &quot;<a class="el" href="fl__stdlib_8h_source.html">falco/fl_stdlib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fl__bits_8h_source.html">falco/fl_bits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fl__tracevalue_8h_source.html">falco/fl_tracevalue.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for fl_socket.h:</div>
<div class="dyncontent">
<div class="center"><img src="fl__socket_8h__incl.png" border="0" usemap="#include_2falco_2fl__socket_8h" alt=""/></div>
<map name="include_2falco_2fl__socket_8h" id="include_2falco_2fl__socket_8h">
<area shape="rect" id="node9" href="fl__stdlib_8h.html" title="Convenience macros for assertion, memory allocation. " alt="" coords="586,80,696,107"/>
<area shape="rect" id="node15" href="fl__bits_8h.html" title="Convenience macros for operations on bits. " alt="" coords="828,155,928,181"/>
<area shape="rect" id="node16" href="fl__tracevalue_8h.html" title="Trace utility. " alt="" coords="721,80,860,107"/>
<area shape="rect" id="node12" href="fl__logr_8h.html" title="Logging and Tracing. " alt="" coords="252,155,352,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="fl__socket_8h__dep__incl.png" border="0" usemap="#include_2falco_2fl__socket_8hdep" alt=""/></div>
<map name="include_2falco_2fl__socket_8hdep" id="include_2falco_2fl__socket_8hdep">
<area shape="rect" id="node2" href="fl__task_8h.html" title="Task Management. " alt="" coords="12,80,161,107"/>
<area shape="rect" id="node3" href="fl__timer_8h.html" title="Timer Management. " alt="" coords="10,155,163,181"/>
</map>
</div>
</div>
<p><a href="fl__socket_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfl__socket__t__.html">fl_socket_t_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falco Socket.  <a href="structfl__socket__t__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1f6857c1e060cd9870b7ba88be6af785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6857c1e060cd9870b7ba88be6af785"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a1f6857c1e060cd9870b7ba88be6af785">FL_SOCKET_NAME_MAX_LEN</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a1f6857c1e060cd9870b7ba88be6af785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a socket name (including the trailing delimiter). <br /></td></tr>
<tr class="separator:a1f6857c1e060cd9870b7ba88be6af785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab362d937c00eef3545f84dac69b30ae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab362d937c00eef3545f84dac69b30ae6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#ab362d937c00eef3545f84dac69b30ae6">FL_SOCKF_BOUND_IN</a>&#160;&#160;&#160;BITVAL(0x00000001)</td></tr>
<tr class="memdesc:ab362d937c00eef3545f84dac69b30ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the state that the socket is bound to an IPv4 address. <br /></td></tr>
<tr class="separator:ab362d937c00eef3545f84dac69b30ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bca1261c11f54a21948a3131859ba6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61bca1261c11f54a21948a3131859ba6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a61bca1261c11f54a21948a3131859ba6">FL_SOCKF_BOUND_IN6</a>&#160;&#160;&#160;BITVAL(0x00000002)</td></tr>
<tr class="memdesc:a61bca1261c11f54a21948a3131859ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the state that the socket is bound to an IPv6 address. <br /></td></tr>
<tr class="separator:a61bca1261c11f54a21948a3131859ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dd3ea62a0bdcb98862d0938393e53d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56dd3ea62a0bdcb98862d0938393e53d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a56dd3ea62a0bdcb98862d0938393e53d">FL_SOCKF_BOUND_UNIX</a>&#160;&#160;&#160;BITVAL(0x00000004)</td></tr>
<tr class="memdesc:a56dd3ea62a0bdcb98862d0938393e53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the state that the socket is bound to a Unix path. <br /></td></tr>
<tr class="separator:a56dd3ea62a0bdcb98862d0938393e53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd710a5fa6ae03d6055babf59e3f04d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbd710a5fa6ae03d6055babf59e3f04d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#adbd710a5fa6ae03d6055babf59e3f04d">FL_SOCKF_CONNECTED</a>&#160;&#160;&#160;BITVAL(0x00000008)</td></tr>
<tr class="memdesc:adbd710a5fa6ae03d6055babf59e3f04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the state that the socket is connected. <br /></td></tr>
<tr class="separator:adbd710a5fa6ae03d6055babf59e3f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e84c1f76cf8d803540708526ba5b90a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e84c1f76cf8d803540708526ba5b90a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a1e84c1f76cf8d803540708526ba5b90a">FL_SOCKF_LISTEN</a>&#160;&#160;&#160;BITVAL(0x00000010)</td></tr>
<tr class="memdesc:a1e84c1f76cf8d803540708526ba5b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate the state that the socket is listening for connections. <br /></td></tr>
<tr class="separator:a1e84c1f76cf8d803540708526ba5b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa362186dbaf0bb2c3529f0f1ccb7111c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa362186dbaf0bb2c3529f0f1ccb7111c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa362186dbaf0bb2c3529f0f1ccb7111c">FL_SOCKF_NONBLOCKING</a>&#160;&#160;&#160;BITVAL(0x00000020)</td></tr>
<tr class="memdesc:aa362186dbaf0bb2c3529f0f1ccb7111c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate that non-blocking option has been set for the socket operations. <br /></td></tr>
<tr class="separator:aa362186dbaf0bb2c3529f0f1ccb7111c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe6ff5b317fc30c76a05723823eae79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbe6ff5b317fc30c76a05723823eae79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#abbe6ff5b317fc30c76a05723823eae79">FL_SOCKF_RCVWAIT</a>&#160;&#160;&#160;BITVAL(0x00000040)</td></tr>
<tr class="memdesc:abbe6ff5b317fc30c76a05723823eae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate that recevie wait option has been set on the socket. <br /></td></tr>
<tr class="separator:abbe6ff5b317fc30c76a05723823eae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd7ba22fea752d7373af742777f45d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd7ba22fea752d7373af742777f45d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a1bd7ba22fea752d7373af742777f45d6">FL_SOCKADDR_STR_MAX_LEN</a>&#160;&#160;&#160;130</td></tr>
<tr class="memdesc:a1bd7ba22fea752d7373af742777f45d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of the string (including the trailing delimiter) that represents a socket address in a printable (presentation) format. <br /></td></tr>
<tr class="separator:a1bd7ba22fea752d7373af742777f45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0a57d0681c12e065c3d2d14ceba9a23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a57d0681c12e065c3d2d14ceba9a23b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a0a57d0681c12e065c3d2d14ceba9a23b">fl_socket_accept_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a0a57d0681c12e065c3d2d14ceba9a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that implement connection accept method. <br /></td></tr>
<tr class="separator:a0a57d0681c12e065c3d2d14ceba9a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fe219e25e66a1bf4c382816684aa74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78fe219e25e66a1bf4c382816684aa74"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a78fe219e25e66a1bf4c382816684aa74">fl_socket_connect_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a78fe219e25e66a1bf4c382816684aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that implement connect method. <br /></td></tr>
<tr class="separator:a78fe219e25e66a1bf4c382816684aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75a31267ee29abf5b3a0f64662f463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa75a31267ee29abf5b3a0f64662f463"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#afa75a31267ee29abf5b3a0f64662f463">fl_socket_connect_error_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *, int)</td></tr>
<tr class="memdesc:afa75a31267ee29abf5b3a0f64662f463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods to handle errors returned from connect. <br /></td></tr>
<tr class="separator:afa75a31267ee29abf5b3a0f64662f463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10df5b3981ae1918ef9d38e9887c77b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10df5b3981ae1918ef9d38e9887c77b0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a10df5b3981ae1918ef9d38e9887c77b0">fl_socket_connect_complete_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a10df5b3981ae1918ef9d38e9887c77b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods to handle the completion of a connection. <br /></td></tr>
<tr class="separator:a10df5b3981ae1918ef9d38e9887c77b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf803322787bcb24ae9b85a0e7f8639"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf803322787bcb24ae9b85a0e7f8639"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a2cf803322787bcb24ae9b85a0e7f8639">fl_socket_recv_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *, void *buf, size_t len, struct sockaddr *src_addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a2cf803322787bcb24ae9b85a0e7f8639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that handle reception of packets or datagrams. <br /></td></tr>
<tr class="separator:a2cf803322787bcb24ae9b85a0e7f8639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c3f3fc62d0620e0cace560e5626f52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43c3f3fc62d0620e0cace560e5626f52"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a43c3f3fc62d0620e0cace560e5626f52">fl_socket_nb_recv_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a43c3f3fc62d0620e0cace560e5626f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that implement non-blocking receive operation. <br /></td></tr>
<tr class="separator:a43c3f3fc62d0620e0cace560e5626f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9419384e8bafbc893594285671b55f83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9419384e8bafbc893594285671b55f83"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a9419384e8bafbc893594285671b55f83">fl_socket_recv_is_msg_complete_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a9419384e8bafbc893594285671b55f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that check if a message has been received completely. <br /></td></tr>
<tr class="separator:a9419384e8bafbc893594285671b55f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325320c8d191b5522b28a3cd9ddb2ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa325320c8d191b5522b28a3cd9ddb2ab"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa325320c8d191b5522b28a3cd9ddb2ab">fl_socket_recv_complete_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:aa325320c8d191b5522b28a3cd9ddb2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that handle reception of packets or datagrams. <br /></td></tr>
<tr class="separator:aa325320c8d191b5522b28a3cd9ddb2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b65e3cef54bfa6a8253a874160f9553"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b65e3cef54bfa6a8253a874160f9553"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a1b65e3cef54bfa6a8253a874160f9553">fl_socket_recv_error_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a1b65e3cef54bfa6a8253a874160f9553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods to handle errors encountered during receive operation. <br /></td></tr>
<tr class="separator:a1b65e3cef54bfa6a8253a874160f9553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda09dbd52d5059af3724c882cbd407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcda09dbd52d5059af3724c882cbd407"></a>
typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#abcda09dbd52d5059af3724c882cbd407">fl_socket_send_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *, void *buf, size_t len, const struct sockaddr *dest_addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:abcda09dbd52d5059af3724c882cbd407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that implement tranmission of packets or datagrams. <br /></td></tr>
<tr class="separator:abcda09dbd52d5059af3724c882cbd407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8337bcebc8fb33c914b3fa2cfd6c1ef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8337bcebc8fb33c914b3fa2cfd6c1ef6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a8337bcebc8fb33c914b3fa2cfd6c1ef6">fl_socket_nb_send_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:a8337bcebc8fb33c914b3fa2cfd6c1ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods that implement non-blocking tranmission of packets or datagrams. <br /></td></tr>
<tr class="separator:a8337bcebc8fb33c914b3fa2cfd6c1ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5524929526451e515ac685deab6b7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5524929526451e515ac685deab6b7f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#afa5524929526451e515ac685deab6b7f">fl_socket_send_complete_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:afa5524929526451e515ac685deab6b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods to handle the completion of a transmit operation. <br /></td></tr>
<tr class="separator:afa5524929526451e515ac685deab6b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f77449ebc7177f47d7359dac5d289b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3f77449ebc7177f47d7359dac5d289b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa3f77449ebc7177f47d7359dac5d289b">fl_socket_send_error_method_t</a>) (struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a> *)</td></tr>
<tr class="memdesc:aa3f77449ebc7177f47d7359dac5d289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for methods to handle errors encountered during transmit/send operation. <br /></td></tr>
<tr class="separator:aa3f77449ebc7177f47d7359dac5d289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93828b397cacd5814187a65e9c6ecf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93828b397cacd5814187a65e9c6ecf8"></a>
typedef struct <a class="el" href="structfl__socket__t__.html">fl_socket_t_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a></td></tr>
<tr class="memdesc:aa93828b397cacd5814187a65e9c6ecf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falco Socket. <br /></td></tr>
<tr class="separator:aa93828b397cacd5814187a65e9c6ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03be490abd72a420a7ae35fe681ec33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa03be490abd72a420a7ae35fe681ec33"></a>
typedef enum <a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fe">fl_sockoption_e_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa03be490abd72a420a7ae35fe681ec33">fl_sockoption_e</a></td></tr>
<tr class="memdesc:aa03be490abd72a420a7ae35fe681ec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falco Socket Options. <br /></td></tr>
<tr class="separator:aa03be490abd72a420a7ae35fe681ec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1fd362c1eac98ad4a1d63bee67f009fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fe">fl_sockoption_e_</a> { <br />
&#160;&#160;<b>FL_SOCKOPT_MIN</b> = 1, 
<a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fea218c747f9235d49196d7bfab5cad56d8">FL_SOCKOPT_NONBLOCKING</a> = FL_SOCKOPT_MIN, 
<a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009feaf854139565fc0eaf8a59d09de5f632e2">FL_SOCKOPT_RCVWAIT</a>, 
<a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fea39aa45df36bb38a7de55dea8edaa50ee">FL_SOCKOPT_RCVTIMEO</a>, 
<br />
&#160;&#160;<a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009feac434b5e69c1ad8cf24be2734a0bb2f60">FL_SOCKOPT_SNDTIMEO</a>, 
<b>FL_SOCKOPT_MAX</b> = FL_SOCKOPT_SNDTIMEO
<br />
 }<tr class="memdesc:a1fd362c1eac98ad4a1d63bee67f009fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falco Socket Options.  <a href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1fd362c1eac98ad4a1d63bee67f009fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58488c4eb94d612f5b2d1df4cfebd606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a58488c4eb94d612f5b2d1df4cfebd606">fl_socket_module_init</a> (void)</td></tr>
<tr class="memdesc:a58488c4eb94d612f5b2d1df4cfebd606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize socket and communications module.  <a href="#a58488c4eb94d612f5b2d1df4cfebd606">More...</a><br /></td></tr>
<tr class="separator:a58488c4eb94d612f5b2d1df4cfebd606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8febe194ebd02944abdef4fe4c30e075"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a8febe194ebd02944abdef4fe4c30e075">fl_socket_module_dump</a> (FILE *fd)</td></tr>
<tr class="memdesc:a8febe194ebd02944abdef4fe4c30e075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the status and state of the module.  <a href="#a8febe194ebd02944abdef4fe4c30e075">More...</a><br /></td></tr>
<tr class="separator:a8febe194ebd02944abdef4fe4c30e075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab371ad6432e46975840f5bf4a63dbc7"><td class="memItemLeft" align="right" valign="top">struct sockaddr_storage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aab371ad6432e46975840f5bf4a63dbc7">fl_sockaddr_dup</a> (struct sockaddr_storage *dst, const struct sockaddr_storage *src, socklen_t srclen)</td></tr>
<tr class="memdesc:aab371ad6432e46975840f5bf4a63dbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a socket address (representation of <code>sockaddr_storage</code>).  <a href="#aab371ad6432e46975840f5bf4a63dbc7">More...</a><br /></td></tr>
<tr class="separator:aab371ad6432e46975840f5bf4a63dbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1b6439e02df2ab77c3daf1bca5a470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aad1b6439e02df2ab77c3daf1bca5a470">fl_sockaddr_cmp</a> (const struct sockaddr *sa1, const struct sockaddr *sa2)</td></tr>
<tr class="memdesc:aad1b6439e02df2ab77c3daf1bca5a470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two socket addresses.  <a href="#aad1b6439e02df2ab77c3daf1bca5a470">More...</a><br /></td></tr>
<tr class="separator:aad1b6439e02df2ab77c3daf1bca5a470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2f6cb956b9242ebf7584269963502a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a5c2f6cb956b9242ebf7584269963502a">fl_sockaddr_nw_cmp</a> (const struct sockaddr *sa1, const struct sockaddr *sa2, const struct sockaddr *netmask)</td></tr>
<tr class="memdesc:a5c2f6cb956b9242ebf7584269963502a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the network portion of two socket addresses.  <a href="#a5c2f6cb956b9242ebf7584269963502a">More...</a><br /></td></tr>
<tr class="separator:a5c2f6cb956b9242ebf7584269963502a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2380bf72fee72d7d3570c136d01f7c4"><td class="memItemLeft" align="right" valign="top">socklen_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#ac2380bf72fee72d7d3570c136d01f7c4">fl_sockaddr_len</a> (struct sockaddr *sa)</td></tr>
<tr class="memdesc:ac2380bf72fee72d7d3570c136d01f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a socket address (represented as <code>sockaddr</code>).  <a href="#ac2380bf72fee72d7d3570c136d01f7c4">More...</a><br /></td></tr>
<tr class="separator:ac2380bf72fee72d7d3570c136d01f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62669e0802db284263fbb27a933a3235"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a62669e0802db284263fbb27a933a3235">fl_sockaddr_ntop</a> (const struct sockaddr_storage *ss, char *dst, socklen_t size)</td></tr>
<tr class="memdesc:a62669e0802db284263fbb27a933a3235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a socket address from binary to text form.  <a href="#a62669e0802db284263fbb27a933a3235">More...</a><br /></td></tr>
<tr class="separator:a62669e0802db284263fbb27a933a3235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589f0d46d840cde36fbbc92b95836a49"><td class="memItemLeft" align="right" valign="top">u_int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a589f0d46d840cde36fbbc92b95836a49">fl_sockaddr_port_hbo</a> (const struct sockaddr_storage *ss)</td></tr>
<tr class="memdesc:a589f0d46d840cde36fbbc92b95836a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the port in a socket address to host byte order.  <a href="#a589f0d46d840cde36fbbc92b95836a49">More...</a><br /></td></tr>
<tr class="separator:a589f0d46d840cde36fbbc92b95836a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900c7b1fd7ca8ae20de96b148ff0934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934">fl_socket_socket</a> (struct <a class="el" href="structfl__task__t__.html">fl_task_t_</a> *task, const char *name, int domain, int type, int protocol)</td></tr>
<tr class="memdesc:aa900c7b1fd7ca8ae20de96b148ff0934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an endpoint for communication.  <a href="#aa900c7b1fd7ca8ae20de96b148ff0934">More...</a><br /></td></tr>
<tr class="separator:aa900c7b1fd7ca8ae20de96b148ff0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e56b280cc744f9a7b3fe7d6f494167"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a26e56b280cc744f9a7b3fe7d6f494167">fl_socket_setsockopt</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#aa03be490abd72a420a7ae35fe681ec33">fl_sockoption_e</a> option,...)</td></tr>
<tr class="memdesc:a26e56b280cc744f9a7b3fe7d6f494167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set options on falco sockets.  <a href="#a26e56b280cc744f9a7b3fe7d6f494167">More...</a><br /></td></tr>
<tr class="separator:a26e56b280cc744f9a7b3fe7d6f494167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec528fb8fbfd7e88412425267ff95c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a9ec528fb8fbfd7e88412425267ff95c8">fl_socket_bind</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, const struct sockaddr_storage *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a9ec528fb8fbfd7e88412425267ff95c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a name to a falco socket.  <a href="#a9ec528fb8fbfd7e88412425267ff95c8">More...</a><br /></td></tr>
<tr class="separator:a9ec528fb8fbfd7e88412425267ff95c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e2e58c89b6170e1ae05730fc40973"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a455e2e58c89b6170e1ae05730fc40973">fl_socket_listen</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, int backlog)</td></tr>
<tr class="memdesc:a455e2e58c89b6170e1ae05730fc40973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a falco socket.  <a href="#a455e2e58c89b6170e1ae05730fc40973">More...</a><br /></td></tr>
<tr class="separator:a455e2e58c89b6170e1ae05730fc40973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afe54d4e1004a99eac112d855a88cf4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a2afe54d4e1004a99eac112d855a88cf4">fl_socket_select</a> (fd_set **rfds, fd_set **wfds, fd_set **efds)</td></tr>
<tr class="memdesc:a2afe54d4e1004a99eac112d855a88cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I/O multiplexing.  <a href="#a2afe54d4e1004a99eac112d855a88cf4">More...</a><br /></td></tr>
<tr class="separator:a2afe54d4e1004a99eac112d855a88cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e85f0872e7200f1ea556f86a1c438a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a3e85f0872e7200f1ea556f86a1c438a9">fl_socket_generic_accept</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk)</td></tr>
<tr class="memdesc:a3e85f0872e7200f1ea556f86a1c438a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on a socket.  <a href="#a3e85f0872e7200f1ea556f86a1c438a9">More...</a><br /></td></tr>
<tr class="separator:a3e85f0872e7200f1ea556f86a1c438a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822731d7a6c65cd0bfbffc84a1dec32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a9822731d7a6c65cd0bfbffc84a1dec32">fl_socket_generic_connect</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, const struct sockaddr_storage *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a9822731d7a6c65cd0bfbffc84a1dec32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection on a socket.  <a href="#a9822731d7a6c65cd0bfbffc84a1dec32">More...</a><br /></td></tr>
<tr class="separator:a9822731d7a6c65cd0bfbffc84a1dec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823761075a089dd628c80d31dbd3259"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#ae823761075a089dd628c80d31dbd3259">fl_socket_generic_recv</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, void *buf, size_t len, struct sockaddr_storage *src_addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:ae823761075a089dd628c80d31dbd3259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a socket.  <a href="#ae823761075a089dd628c80d31dbd3259">More...</a><br /></td></tr>
<tr class="separator:ae823761075a089dd628c80d31dbd3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefde97b455474ebf48390836f2b03240"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#aefde97b455474ebf48390836f2b03240">fl_socket_generic_send</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, void *buf, size_t len, const struct sockaddr_storage *dest_addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:aefde97b455474ebf48390836f2b03240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message on a socket.  <a href="#aefde97b455474ebf48390836f2b03240">More...</a><br /></td></tr>
<tr class="separator:aefde97b455474ebf48390836f2b03240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af385fbf1e2af7d1c74d7c14d98d2b5a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#af385fbf1e2af7d1c74d7c14d98d2b5a7">fl_socket_set_connect_complete_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#a10df5b3981ae1918ef9d38e9887c77b0">fl_socket_connect_complete_method_t</a> connect_complete_method)</td></tr>
<tr class="memdesc:af385fbf1e2af7d1c74d7c14d98d2b5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket connection complete handler method.  <a href="#af385fbf1e2af7d1c74d7c14d98d2b5a7">More...</a><br /></td></tr>
<tr class="separator:af385fbf1e2af7d1c74d7c14d98d2b5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269be3ee6196df31c008dc4e7cc4c83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a269be3ee6196df31c008dc4e7cc4c83b">fl_socket_set_recv_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#a2cf803322787bcb24ae9b85a0e7f8639">fl_socket_recv_method_t</a> recv_method)</td></tr>
<tr class="memdesc:a269be3ee6196df31c008dc4e7cc4c83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set receive handler method.  <a href="#a269be3ee6196df31c008dc4e7cc4c83b">More...</a><br /></td></tr>
<tr class="separator:a269be3ee6196df31c008dc4e7cc4c83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b14bdf2ae0a071c318c571f533ad11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a40b14bdf2ae0a071c318c571f533ad11">fl_socket_set_nb_recv_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#a43c3f3fc62d0620e0cace560e5626f52">fl_socket_nb_recv_method_t</a> nb_recv_method)</td></tr>
<tr class="memdesc:a40b14bdf2ae0a071c318c571f533ad11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set non-blocking receive handler method.  <a href="#a40b14bdf2ae0a071c318c571f533ad11">More...</a><br /></td></tr>
<tr class="separator:a40b14bdf2ae0a071c318c571f533ad11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97fce09a1bdcff2cae01bc637377b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#ab97fce09a1bdcff2cae01bc637377b87">fl_socket_set_recv_is_msg_complete_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#a9419384e8bafbc893594285671b55f83">fl_socket_recv_is_msg_complete_method_t</a> recv_is_msg_complete_method)</td></tr>
<tr class="memdesc:ab97fce09a1bdcff2cae01bc637377b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method that checks if a received message is complete.  <a href="#ab97fce09a1bdcff2cae01bc637377b87">More...</a><br /></td></tr>
<tr class="separator:ab97fce09a1bdcff2cae01bc637377b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1324d07df7531e8fe1249c5347474c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a8a1324d07df7531e8fe1249c5347474c">fl_socket_set_recv_complete_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#aa325320c8d191b5522b28a3cd9ddb2ab">fl_socket_recv_complete_method_t</a> recv_complete_method)</td></tr>
<tr class="memdesc:a8a1324d07df7531e8fe1249c5347474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method to notify the application that a complete message has been received.  <a href="#a8a1324d07df7531e8fe1249c5347474c">More...</a><br /></td></tr>
<tr class="separator:a8a1324d07df7531e8fe1249c5347474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19814d25e12b0ecb469115d2c472c08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#ab19814d25e12b0ecb469115d2c472c08">fl_socket_set_send_complete_method</a> (<a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *flsk, <a class="el" href="fl__socket_8h.html#afa5524929526451e515ac685deab6b7f">fl_socket_send_complete_method_t</a> send_complete_method)</td></tr>
<tr class="memdesc:ab19814d25e12b0ecb469115d2c472c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method to notify the application that a message has been sent.  <a href="#ab19814d25e12b0ecb469115d2c472c08">More...</a><br /></td></tr>
<tr class="separator:ab19814d25e12b0ecb469115d2c472c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0df6de151852cb197b5b58610d4514b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#af0df6de151852cb197b5b58610d4514b">fl_socket_process_reads</a> (int *nfds, fd_set *fds)</td></tr>
<tr class="memdesc:af0df6de151852cb197b5b58610d4514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read operation on sockets.  <a href="#af0df6de151852cb197b5b58610d4514b">More...</a><br /></td></tr>
<tr class="separator:af0df6de151852cb197b5b58610d4514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb099a973bda9b8b5ea03435e9498e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a6cb099a973bda9b8b5ea03435e9498e1">fl_socket_process_writes</a> (int *nfds, fd_set *fds)</td></tr>
<tr class="memdesc:a6cb099a973bda9b8b5ea03435e9498e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform write operation on sockets.  <a href="#a6cb099a973bda9b8b5ea03435e9498e1">More...</a><br /></td></tr>
<tr class="separator:a6cb099a973bda9b8b5ea03435e9498e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6311b8338250a34021a0ea6c93700a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fl__socket_8h.html#a6311b8338250a34021a0ea6c93700a29">fl_socket_process_connections</a> (int *nfds, fd_set *fds)</td></tr>
<tr class="memdesc:a6311b8338250a34021a0ea6c93700a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process new connections on sockets that are in listen mode.  <a href="#a6311b8338250a34021a0ea6c93700a29">More...</a><br /></td></tr>
<tr class="separator:a6311b8338250a34021a0ea6c93700a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a1fd362c1eac98ad4a1d63bee67f009fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fl__socket_8h.html#a1fd362c1eac98ad4a1d63bee67f009fe">fl_sockoption_e_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Falco Socket Options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1fd362c1eac98ad4a1d63bee67f009fea218c747f9235d49196d7bfab5cad56d8"></a>FL_SOCKOPT_NONBLOCKING&#160;</td><td class="fielddoc">
<p>Non-Blocking option for the socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1fd362c1eac98ad4a1d63bee67f009feaf854139565fc0eaf8a59d09de5f632e2"></a>FL_SOCKOPT_RCVWAIT&#160;</td><td class="fielddoc">
<p>Recv-Wait option for the socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1fd362c1eac98ad4a1d63bee67f009fea39aa45df36bb38a7de55dea8edaa50ee"></a>FL_SOCKOPT_RCVTIMEO&#160;</td><td class="fielddoc">
<p>Maps to SO_RCVTIMEO (Receive TimeOut) for the socket. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1fd362c1eac98ad4a1d63bee67f009feac434b5e69c1ad8cf24be2734a0bb2f60"></a>FL_SOCKOPT_SNDTIMEO&#160;</td><td class="fielddoc">
<p>Maps to SO_SNDTIMEO (Send TimeOut) for the socket. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aad1b6439e02df2ab77c3daf1bca5a470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_sockaddr_cmp </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two socket addresses. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns -1, 0, or 1 if <code>sa1</code> is found to be less than, to match, or be greater than <code>sa2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aab371ad6432e46975840f5bf4a63dbc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sockaddr_storage* fl_sockaddr_dup </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>srclen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a socket address (representation of <code>sockaddr_storage</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination socket address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source socket address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srclen</td><td>Length of <code>src</code>. Must be atleast <code>sizeof(sockaddr_in)</code>, and cannot exceed <code>sizeof(sockaddr_storage)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, <code>dst</code> is returned. On error, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2380bf72fee72d7d3570c136d01f7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">socklen_t fl_sockaddr_len </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of a socket address (represented as <code>sockaddr</code>). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the address if the socket address family/domain is supported. Otherwise, 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a62669e0802db284263fbb27a933a3235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fl_sockaddr_ntop </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a socket address from binary to text form. </p>
<p>This function converts the network address structure <code>ss</code> (in the address family <code>ss-&gt;ss_family</code>) into a character string. For socket addresses belonging to family AF_INET or AF_INET6, the resulting string is copied to the buffer pointed to by dst, which must be a non-null pointer.</p>
<p>For socket addresses belonging to the AF_UNIX family, the buffer pointed to by dst is unchanged. The unix path of the socket is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a non-null pointer to <code>dst</code> if the address family is supported. Otherwise, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2f6cb956b9242ebf7584269963502a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_sockaddr_nw_cmp </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the network portion of two socket addresses. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns -1, 0, or 1 if <code>sa1</code> is found to be less than, to match, or be greater than <code>sa2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a589f0d46d840cde36fbbc92b95836a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int16_t fl_sockaddr_port_hbo </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the port in a socket address to host byte order. </p>
<p>This function converts the port in a socket address from network byte order to host byte order.</p>
<dl class="section return"><dt>Returns</dt><dd>For socket addresses belonging to AF_INET or AF_INET6 family, an unsigned short integer in host byte order is returned. For socket addresses belonging to AF_UNIX family, 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec528fb8fbfd7e88412425267ff95c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a name to a falco socket. </p>
<p>This function assigns the address specified by <code>addr</code> to the sockfd (contained within the falco socket).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Local address to bind to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>The size, in bytes, of the address structure pointed to by <code>addr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>bind(2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e85f0872e7200f1ea556f86a1c438a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_generic_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on a socket. </p>
<p>This function is used with connection-based socket types (SOCK_STREAM). It uses the <code>accept(2)</code> system call to process pending connections.</p>
<p>On successful connection to a client, a new falco socket is created. Its fd is set to the fd returned from <code>accept(2)</code>. The local address is set. For AF_INET and AF_INET6 families, the remote address is set from the remote address returned from <code>accept(2)</code>. The application is then notified of the new connection by invoking the <code>connect_complete_method()</code> which implements <a class="el" href="fl__socket_8h.html#a10df5b3981ae1918ef9d38e9887c77b0" title="Type definition for methods to handle the completion of a connection. ">fl_socket_connect_complete_method_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>accept(2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a9822731d7a6c65cd0bfbffc84a1dec32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_generic_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection on a socket. </p>
<p>A generic implementation of <code>connect(2)</code> that applications can use readily. This function uses the <code>connect(2)</code> system call to connect the socket referred to by sockfd (contained within the falco socket) to the address by <code>addr</code>.</p>
<p>On successful connection, a new falco socket is created. The local address and remote address is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Remote address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Specifies the size of <code>addr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>connect(2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae823761075a089dd628c80d31dbd3259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fl_socket_generic_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from a socket. </p>
<p>A generic implementation of <code>recv(2)</code> that applications can use readily. This function employs <code>recvfrom(2)</code> for SOCK_DGRAM, <code>recvmsg(2)</code> for SOCK_RAW and <code>recv(2)</code> for SOCK_STREAM.</p>
<p>If src_addr is not NULL, and the underlying protocol provides the source address of the message, that source address is placed in the buffer pointed to by src_addr. <code>addrlen</code> is updated to contain the actual size of the source address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Buffer to store the received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the buffer <code>buf</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">src_addr</td><td>Source address of the message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addrlen</td><td>Specifies the size of <code>src_addr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes received is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>recv(2)</code>, recvfrom(2), recvmsg(2) </dd></dl>

</div>
</div>
<a class="anchor" id="aefde97b455474ebf48390836f2b03240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fl_socket_generic_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message on a socket. </p>
<p>A generic implementation of <code>send(2)</code> that applications can use readily. This function employs <code>sendto(2)</code> for SOCK_DGRAM, <code>sendmsg(2)</code> for SOCK_RAW and <code>send(2)</code> for SOCK_STREAM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Send data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the buffer <code>buf</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_addr</td><td>Destination address of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>Specifies the size of <code>dest_addr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes sent is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>send(2)</code>, sendto(2), sendmsg(2) </dd></dl>

</div>
</div>
<a class="anchor" id="a455e2e58c89b6170e1ae05730fc40973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Listen for connections on a falco socket. </p>
<p>Marks the sockfd (contained within the falco socket) as a passive socket, that is, as a socket that will be used to accept incoming connection requests using <code>accept(2)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Defines the maximum length to which the queue or pending socket fd may grow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>listen(2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8febe194ebd02944abdef4fe4c30e075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_module_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the status and state of the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Stream to which the status and state of all modules needs to be written. If this parameter is NULL, then the output is written to syslog.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a58488c4eb94d612f5b2d1df4cfebd606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_module_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize socket and communications module. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a6311b8338250a34021a0ea6c93700a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_process_connections </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process new connections on sockets that are in listen mode. </p>
<p>This function performs read operations on socket file descriptors which have become ready to accept new connections. It calls the accept method that has been previously registered for the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Number</td><td>of FDs that are ready for I/O operations. It is decremented by the number of FDs on which new connections have been processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fds</td><td>Read FD set. FDs on which the new connections have been processed are cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#a2afe54d4e1004a99eac112d855a88cf4" title="Synchronous I/O multiplexing. ">fl_socket_select()</a>, <a class="el" href="fl__socket_8h.html#a455e2e58c89b6170e1ae05730fc40973" title="Listen for connections on a falco socket. ">fl_socket_listen()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0df6de151852cb197b5b58610d4514b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_process_reads </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform read operation on sockets. </p>
<p>This function performs read operations on socket file descriptors which have become ready for read. It calls the non-blocking receive method that has been previously registered for the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Number</td><td>of FDs that are ready for I/O operations. It is decremented by the number of FDs on which read operation has been performed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fds</td><td>Read FD set. FDs on which the read operation has been performed are cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#a2afe54d4e1004a99eac112d855a88cf4" title="Synchronous I/O multiplexing. ">fl_socket_select()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb099a973bda9b8b5ea03435e9498e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_process_writes </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&#160;</td>
          <td class="paramname"><em>fds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform write operation on sockets. </p>
<p>This function performs write operations on socket file descriptors which have become ready for write. It calls the non-blocking send method that has been previously registered for the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Number</td><td>of FDs that are ready for I/O operations. It is decremented by the number of FDs on which write operation has been performed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fds</td><td>Read FD set. FDs on which the write operation has been performed are cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#a2afe54d4e1004a99eac112d855a88cf4" title="Synchronous I/O multiplexing. ">fl_socket_select()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2afe54d4e1004a99eac112d855a88cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_select </td>
          <td>(</td>
          <td class="paramtype">fd_set **&#160;</td>
          <td class="paramname"><em>rfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set **&#160;</td>
          <td class="paramname"><em>wfds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set **&#160;</td>
          <td class="paramname"><em>efds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronous I/O multiplexing. </p>
<p>Allows an application to monitor multiple file descriptors, waiting until one or more of the file descriptors become ready for some class of I/O operation. For example, read or write operation.</p>
<p>The falco File Descriptors (FDs) management module keeps track or maintains (socket) file descriptors that were created by calling <a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934" title="Create an endpoint for communication. ">fl_socket_socket()</a>. In addition, the application can also directly access <a class="el" href="fl__fds_8h.html#a687c1cd35e0c48c39e050f4b62a77a96" title="Set read/accept or write except bit for the supplied file descriptor. ">FL_FD_SET</a> macro to tell the FDs management module to track an FD for a certain operation. <code>rfds</code>, <code>wfds</code> and <code>efds</code> are independent sets of FDs and are watched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rfds</td><td>Set of file descriptors to be watched for write </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wfds</td><td>Set of file descriptors to be watched for read </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">efds</td><td>Set of file descriptors to be watched for exceptions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>select(2)</code>, <a class="el" href="fl__fds_8h.html#a687c1cd35e0c48c39e050f4b62a77a96" title="Set read/accept or write except bit for the supplied file descriptor. ">FL_FD_SET</a>, <a class="el" href="fl__fds_8h.html#a0c1f139808e23b6fa8be2b398b9cdedf" title="Clear read/accept or write except bit for the supplied file descriptor. ">FL_FD_CLR</a>, <a class="el" href="fl__fds_8h.html#aaec30cf63bd3ffade5f3d7f1aa619b3a" title="Clear bits of all file descriptors for an operation. ">FL_FD_ZERO</a>, <a class="el" href="fl__fds_8h.html#ab6de19ad8cea0eca6ab6e5be6f83df45" title="Check to see if a file descriptor is set for an operation. ">fl_fd_isset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af385fbf1e2af7d1c74d7c14d98d2b5a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_connect_complete_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#a10df5b3981ae1918ef9d38e9887c77b0">fl_socket_connect_complete_method_t</a>&#160;</td>
          <td class="paramname"><em>connect_complete_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket connection complete handler method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connect_complete_method</td><td>Method that is invoked by falco when a socket connection is complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>fl_socket_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="a40b14bdf2ae0a071c318c571f533ad11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_nb_recv_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#a43c3f3fc62d0620e0cace560e5626f52">fl_socket_nb_recv_method_t</a>&#160;</td>
          <td class="paramname"><em>nb_recv_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set non-blocking receive handler method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_recv_method</td><td>Method that is invoked by falco when a message is received (in a non-blocking fashion) on a socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934" title="Create an endpoint for communication. ">fl_socket_socket()</a>, fl_socket_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="a8a1324d07df7531e8fe1249c5347474c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_recv_complete_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa325320c8d191b5522b28a3cd9ddb2ab">fl_socket_recv_complete_method_t</a>&#160;</td>
          <td class="paramname"><em>recv_complete_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set method to notify the application that a complete message has been received. </p>
<p>When sockets are set to operate in a non-blocking mode, falco calls the method to notify the application of a message that has been received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_complete_method</td><td>Pointer to a function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934" title="Create an endpoint for communication. ">fl_socket_socket()</a>, fl_socket_recv() </dd></dl>

</div>
</div>
<a class="anchor" id="ab97fce09a1bdcff2cae01bc637377b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_recv_is_msg_complete_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#a9419384e8bafbc893594285671b55f83">fl_socket_recv_is_msg_complete_method_t</a>&#160;</td>
          <td class="paramname"><em>recv_is_msg_complete_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set method that checks if a received message is complete. </p>
<p>When sockets are set to operate in a non-blocking mode, falco calls the method to check with if a message received on a socket is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_is_msg_complete_method</td><td>Pointer to a function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934" title="Create an endpoint for communication. ">fl_socket_socket()</a>, fl_socket_recv() </dd></dl>

</div>
</div>
<a class="anchor" id="a269be3ee6196df31c008dc4e7cc4c83b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_recv_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#a2cf803322787bcb24ae9b85a0e7f8639">fl_socket_recv_method_t</a>&#160;</td>
          <td class="paramname"><em>recv_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set receive handler method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_method</td><td>Method that is invoked by falco when a message is received on a socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>fl_socket_accept() </dd></dl>

</div>
</div>
<a class="anchor" id="ab19814d25e12b0ecb469115d2c472c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_socket_set_send_complete_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#afa5524929526451e515ac685deab6b7f">fl_socket_send_complete_method_t</a>&#160;</td>
          <td class="paramname"><em>send_complete_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set method to notify the application that a message has been sent. </p>
<p>When sockets are set to operate in a non-blocking mode, falco calls the method to notify the application of a message that has been sent/transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">send_complete_method</td><td>Pointer to a function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fl__socket_8h.html#aa900c7b1fd7ca8ae20de96b148ff0934" title="Create an endpoint for communication. ">fl_socket_socket()</a>, fl_socket_send() </dd></dl>

</div>
</div>
<a class="anchor" id="a26e56b280cc744f9a7b3fe7d6f494167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_socket_setsockopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a> *&#160;</td>
          <td class="paramname"><em>flsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__socket_8h.html#aa03be490abd72a420a7ae35fe681ec33">fl_sockoption_e</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set options on falco sockets. </p>
<p>Manipulate options for the sockfd (contained within a falco socket). This function uses <code>ioctl()</code> to set Non-Blocking option, and <code>setsockopt()</code> to set receive and send timeout options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flsk</td><td>Falco socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Enumerated value from <a class="el" href="fl__socket_8h.html#aa03be490abd72a420a7ae35fe681ec33" title="Falco Socket Options. ">fl_sockoption_e</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>For send and receive timeout options, caller must pass a timeout value (in milliseconds) as the third argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. On error, -1 is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>socket(2)</code>, <code>setsockopt(2)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aa900c7b1fd7ca8ae20de96b148ff0934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fl__socket_8h.html#aa93828b397cacd5814187a65e9c6ecf8">fl_socket_t</a>* fl_socket_socket </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfl__task__t__.html">fl_task_t_</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an endpoint for communication. </p>
<p>Create an endpoint for communication and return a falco socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>(Optional) Task to which this socket needs to be associated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String of length not exceeding <a class="el" href="fl__socket_8h.html#a1f6857c1e060cd9870b7ba88be6af785" title="Maximum length of a socket name (including the trailing delimiter). ">FL_SOCKET_NAME_MAX_LEN</a></td></tr>
  </table>
  </dd>
</dl>
<p>Parameters domain, type, and protocol have the same semantics and definition as in <code>socket(2)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to a structure that represents a falco socket is returned. Otherwise, NULL is returned.</dd></dl>
<p>The pointer to the falco socket structure needs to be freed by the application when it is no longer required.</p>
<dl class="section see"><dt>See also</dt><dd>socket(2) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
